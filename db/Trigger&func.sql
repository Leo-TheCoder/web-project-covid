--Set PatientStatus
CREATE OR REPLACE PROCEDURE UpdatePatientStatus
(c_PatientID INT, c_Status INT)
LANGUAGE SQL
AS 
$$
	UPDATE "patient"
	SET Status = c_Status
	WHERE PatientID = c_PatientID
$$
---++---

--View Get Quarantine Area
CREATE OR REPLACE VIEW Get_Quarantine_Area 
AS
	SELECT QA.areaid, QA.areaname, QA.capacity, QA.occupated, 
		WA.wardname  || ', ' || DI.districtname || ', ' || CO.countryname AS areaAddress
	FROM quarantinearea QA, country CO, district DI, ward WA 
	WHERE QA.countryid = CO.countryid AND QA.districtid = DI.districtid AND QA.wardid = WA.wardid AND QA.deleted = 0
	ORDER BY QA.areaid asc;
---++--

-- Insert pack detail
CREATE OR REPLACE PROCEDURE Insert_pack_detail
(p_ProductPackID packdetail.productpackid%type, p_ProductID packdetail.productid%type, 
 p_Quantity packdetail.quantity%type, p_deleted packdetail.deleted%type)
LANGUAGE SQL
AS
$$
	UPDATE PACKDETAIL
	SET quantity = p_Quantity, deleted = p_deleted
	WHERE productpackid = p_ProductPackID AND productid = p_ProductID;
				  		
	INSERT INTO PACKDETAIL
	(productpackid, productid, quantity, deleted)
	SELECT p_ProductPackID, p_ProductID, p_Quantity, p_deleted
	WHERE NOT EXISTS 
	(
		SELECT * 
		FROM packdetail
		WHERE productpackid= p_ProductPackID AND
			  productid = p_ProductID AND
			  quantity = p_Quantity AND
			  deleted =  p_deleted
	)
$$
---++---

--Update occupated number of quarantine area
CREATE OR REPLACE FUNCTION Update_occupated()
RETURNS TRIGGER
AS $$
BEGIN
	IF(TG_ARGV[0]::INTEGER = 0) THEN
		BEGIN
			UPDATE quarantinearea
			SET occupated = occupated + TG_ARGV[1]::INTEGER
			WHERE areaid = NEW.quarantineareaid;
			
			IF (TG_ARGV[1]::INTEGER = -1) THEN
				BEGIN
					UPDATE PATIENT
					SET ENDDATE = NOW()::TIMESTAMP
					WHERE PATIENTID = NEW.PATIENTID;
				END;
			END IF;
		END;
	ELSE
		BEGIN
			UPDATE quarantinearea
			SET occupated = occupated - 1
			WHERE areaid = OLD.quarantineareaid;
			
			UPDATE quarantinearea
			SET occupated = occupated + 1
			WHERE areaid = NEW.quarantineareaid; 
		END;
	END IF;
	
	RETURN NEW;
END	
$$ LANGUAGE PLPGSQL;
---++---

--Trigger insert patient
CREATE TRIGGER INSERT_PATIENT 
AFTER INSERT ON patient
FOR EACH ROW
EXECUTE PROCEDURE Update_occupated('0', '1')
---++---

--Trigger delete patient
CREATE TRIGGER DELETE_PATIENT 
BEFORE UPDATE OF status ON patient
FOR EACH ROW
WHEN (NEW.status = -1)
EXECUTE PROCEDURE Update_occupated('0', '-1')
---++---

--Trigger change quarantine area
CREATE TRIGGER CHANGE_AREA
AFTER UPDATE OF quarantineareaid on patient
FOR EACH ROW
EXECUTE PROCEDURE Update_occupated('1')
---++---

--UPDATE RECURSIVE STATUS OF PATIENT
CREATE OR REPLACE FUNCTION Update_status()
RETURNS TRIGGER
AS $$
BEGIN
	SET timezone TO 'UTC-7';
	
	IF (NEW.status != 2) THEN
		BEGIN
			UPDATE patient
			SET status = NEW.status + 1
			WHERE patientid IN
			(
				SELECT dc.contact_patient
				FROM patient pa INNER JOIN direct_contact dc ON pa.patientid = dc.contact_patient
				WHERE dc.source_patient = NEW.patientid AND
		  			  DATE_PART('day', NOW()::timestamp - dc.contact_time::timestamp) <= 14 AND
					  pa.status > NEW.status	
			);
		END;
		
	END IF;	
	RETURN NEW;
END	
$$ LANGUAGE PLPGSQL;
---++---

--Trigger update status
CREATE TRIGGER Update_status
AFTER UPDATE OF status ON patient
FOR EACH ROW
WHEN (NEW.status != -1)
EXECUTE PROCEDURE Update_status();
---++---

--VIEW SEE PATIENT
CREATE OR REPLACE VIEW VIEW_PATIENT
AS
	SELECT * 
	FROM PATIENT
	WHERE STATUS != -1
	ORDER BY STATUS ASC,  STARTDATE ASC;
---++---

--VIEW_PRODUCT
CREATE OR REPLACE VIEW VIEW_PRODUCT
AS
	SELECT PRODUCTNAME, PRODUCTPRICE, PRODUCTUNIT
	FROM PRODUCT
	WHERE DELETED != 1
	ORDER BY PRODUCTPRICE ASC, PRODUCTNAME ASC;
---++---

--View Product Pack
CREATE OR REPLACE VIEW VIEW_PRODUCT_PACK
AS
	SELECT PRODUCTPACKNAME, PRODUCTPACKLIMIT, TIMEUNIT FROM PRODUCTPACK
	WHERE DELETED = 0
	ORDER BY PRODUCTPACKLIMIT DESC, TIMEUNIT ASC;
---++---

--VIEW REPORT PACK SELL QUANTITY
CREATE OR REPLACE VIEW R_PACK_SELL_QUANTITY
AS
	SELECT TMP.DATE, TMP.PACKID, PP.PRODUCTPACKNAME, COUNT(*) AS QUANTITY
	FROM 
	(
		SELECT DT.ORDERID, packid, to_char(ACCEPTEDTIME, 'MM-YYYY') AS DATE
		FROM ORDERDETAIL DT JOIN SHOPORDER S ON DT.ORDERID = S.ORDERID 
		GROUP BY DT.ORDERID, packid, to_char(ACCEPTEDTIME, 'MM-YYYY')
		ORDER BY DT.ORDERID ASC
	) AS TMP JOIN PRODUCTPACK PP ON TMP.PACKID = PP.PRODUCTPACKID
	GROUP BY TMP.PACKID, PP.PRODUCTPACKNAME, TMP.DATE
	ORDER BY DATE ASC, PACKID ASC;
	
---++---

--VIEW REPORT PRODUCT CONSUMPTION
CREATE OR REPLACE VIEW R_PRODUCT_CONSUMPTION
AS
	SELECT OD.PRODUCTID, PD.PRODUCTNAME, PD.PRODUCTUNIT, COUNT(*) AS QUANTITY
	FROM ORDERDETAIL OD JOIN PRODUCT PD ON OD.PRODUCTID = PD.PRODUCTID
	GROUP BY OD.PRODUCTID, PD.PRODUCTNAME, PD.PRODUCTUNIT
	ORDER BY PRODUCTID ASC;
---++---


--See direct contact list
CREATE OR REPLACE FUNCTION SEE_DIRECT_CONTACT_LIST 
(c_Patient PATIENT.PATIENTID%TYPE)
RETURNS TABLE(PATIENTNAME PATIENT.PATIENTNAME%TYPE, CONTACT_TIME TIMESTAMP, 
			  STATUS INT, PATIENTPHONE PATIENT.PATIENTPHONE%TYPE, 
			  PATIENTIDNUMBER PATIENT.PATIENTIDNUMBER%TYPE)
AS
$$
	set timezone TO 'UTC-7';
	
	SELECT P.PATIENTNAME, DC.CONTACT_TIME, P.STATUS, P.PATIENTPHONE, P.PATIENTIDNUMBER
	FROM DIRECT_CONTACT DC JOIN PATIENT P ON DC.CONTACT_PATIENT = P.PATIENTID
	WHERE SOURCE_PATIENT = C_PATIENT AND
	DATE_PART('day', NOW()::timestamp - contact_time::timestamp) <= 14;
$$ LANGUAGE SQL

---++---

--INSERT STATUS HISTORY
CREATE OR REPLACE FUNCTION Status_History()
RETURNS TRIGGER
AS $$
BEGIN
	set timezone TO 'UTC-7';
	
	UPDATE STATUS_HISTORY
	SET VALID_TO = NOW()::TIMESTAMP
	WHERE PATIENT_ID = NEW.PATIENTID AND VALID_TO IS NULL;
	
	INSERT INTO STATUS_HISTORY (PATIENT_ID, STATUS)
	VALUES(NEW.PATIENTID, NEW.STATUS);
	
	RETURN NEW;
END
$$ LANGUAGE PLPGSQL;
---++---

--TRIGGER STATUS HISTORY
CREATE TRIGGER STATUS_HISTORY
AFTER INSERT OR UPDATE ON PATIENT
FOR EACH ROW
EXECUTE PROCEDURE STATUS_HISTORY ()
--++--

--GET VIEW NUMBER OF PATIENT AT EACH MONTH OF YEAR
CREATE OR REPLACE FUNCTION R_NUMBER_OF_PATIENT_MONTH()
RETURNS TABLE (DATE VARCHAR(10), F0 INT, F1 INT, F2 INT, F3 INT,F_OUT INT)
LANGUAGE PLPGSQL
AS 
$$
DECLARE
	C_DATE TIMESTAMP; M_DATE TIMESTAMP;
	F0 INT; F1 INT; F2 INT; F3 INT; OUT INT;
	BEGIN
		set timezone TO 'UTC-7';
		SELECT DATE_TRUNC('YEAR', MIN(VALID_FROM)) INTO C_DATE
		FROM STATUS_HISTORY;
		
		SELECT MAKE_DATE(EXTRACT('YEAR' FROM NOW()::TIMESTAMP)::INTEGER,12,1) INTO M_DATE;
		
		CREATE TEMPORARY TABLE STATISTIC
		(DATE VARCHAR(10), F0 INT, F1 INT, F2 INT, F3 INT, F_OUT INT);
		
		LOOP 
			EXIT WHEN C_DATE > M_DATE;
			
			SELECT COUNT(*) INTO F0
			FROM STATUS_HISTORY
			WHERE STATUS = 0 
				AND (VALID_TO IS NULL 
				OR (VALID_TO::DATE >= C_DATE::DATE AND VALID_TO::DATE < (C_DATE + INTERVAL '1 MONTH')::DATE));
				
			SELECT COUNT(*) INTO F1
			FROM STATUS_HISTORY
			WHERE STATUS = 1 
				AND (VALID_TO IS NULL 
				OR (VALID_TO::DATE >= C_DATE::DATE AND VALID_TO::DATE < (C_DATE + INTERVAL '1 MONTH')::DATE));
				
			SELECT COUNT(*) INTO F2
			FROM STATUS_HISTORY
			WHERE STATUS = 2
				AND (VALID_TO IS NULL 
				OR (VALID_TO::DATE >= C_DATE::DATE AND VALID_TO::DATE < (C_DATE + INTERVAL '1 MONTH')::DATE));
			
			SELECT COUNT(*) INTO F3
			FROM STATUS_HISTORY
			WHERE STATUS = 3 
				AND (VALID_TO IS NULL 
				OR (VALID_TO::DATE >= C_DATE::DATE AND VALID_TO::DATE < (C_DATE + INTERVAL '1 MONTH')::DATE));
		
			SELECT COUNT(*) INTO F_OUT
			FROM STATUS_HISTORY
			WHERE STATUS = -1 AND VALID_FROM::DATE <= C_DATE;
				--AND (VALID_TO IS NULL 
				--OR (VALID_TO::DATE >= C_DATE::DATE AND VALID_TO::DATE < (C_DATE + INTERVAL '1 MONTH')::DATE));
		
			INSERT INTO STATISTIC
			VALUES (TO_CHAR(C_DATE,'MM-YYYY'),F0, F1, F2, F3, F_OUT);
			
			C_DATE := C_DATE + INTERVAL '1 MONTH';
		END LOOP;
				
		RETURN QUERY SELECT * FROM STATISTIC;
		DROP TABLE STATISTIC;
	END;
$$ 
---++---

--GET NUMBER OF PATIENT AT EACH YEAR
CREATE OR REPLACE FUNCTION R_NUMBER_OF_PATIENT_YEAR()
RETURNS TABLE (YEAR FLOAT, F0 INT, F1 INT, F2 INT, F3 INT, F_OUT INT)
LANGUAGE PLPGSQL
AS
$$
DECLARE
	CURRENT_YEAR FLOAT; MAX_YEAR FLOAT;
	F0 INT; F1 INT; F2 INT; F3 INT; F_OUT INT;
BEGIN
	set timezone TO 'UTC-7';
	
	SELECT EXTRACT('YEAR' FROM MIN(VALID_FROM)) INTO CURRENT_YEAR
	FROM STATUS_HISTORY;
	
	MAX_YEAR := EXTRACT('YEAR' FROM NOW()::TIMESTAMP);
	
	CREATE TEMP TABLE STATISTIC
	(YEAR FLOAT, F0 INT, F1 INT, F2 INT,F3 INT, F_OUT INT);
	
	LOOP
		EXIT WHEN CURRENT_YEAR > MAX_YEAR;
		
		SELECT COUNT(*) INTO F0
		FROM STATUS_HISTORY
		WHERE STATUS = 0 AND (EXTRACT('YEAR' FROM VALID_TO) <= CURRENT_YEAR OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F1
		FROM STATUS_HISTORY
		WHERE STATUS = 1 AND (EXTRACT('YEAR' FROM VALID_TO) <= CURRENT_YEAR OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F2
		FROM STATUS_HISTORY
		WHERE STATUS = 2 AND (EXTRACT('YEAR' FROM VALID_TO) <= CURRENT_YEAR OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F3
		FROM STATUS_HISTORY
		WHERE STATUS = 3 AND (EXTRACT('YEAR' FROM VALID_TO) <= CURRENT_YEAR OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F_OUT
		FROM STATUS_HISTORY
		WHERE STATUS = -1 AND (EXTRACT('YEAR' FROM VALID_FROM) <= CURRENT_YEAR OR VALID_TO IS NULL);
		
		INSERT INTO STATISTIC
		VALUES(CURRENT_YEAR, F0, F1, F2, F3, F_OUT);
		
		CURRENT_YEAR := CURRENT_YEAR + 1;
	END LOOP;
	
	RETURN QUERY 
		SELECT * FROM STATISTIC;
	DROP TABLE STATISTIC;
END;
$$
---++---

--GET NUMBER OF PATIENT AT EACH DAYS
CREATE OR REPLACE FUNCTION R_NUMBER_OF_PATIENT_DAY()
RETURNS TABLE (DATE DATE, F0 INT, F1 INT, F2 INT, F3 INT, F_OUT INT)
LANGUAGE PLPGSQL
AS
$$
DECLARE
	C_DATE TIMESTAMP; MAX_DATE TIMESTAMP;
	F0 INT; F1 INT; F2 INT; F3 INT; F_OUT INT;
BEGIN
	set timezone TO 'UTC-7';
	
	SELECT date_trunc('year', min(valid_from)) INTO C_DATE
	FROM STATUS_HISTORY;
	
	MAX_DATE := MAKE_DATE(EXTRACT('YEAR' FROM CURRENT_DATE)::INTEGER, 12, 31);
	
	CREATE TEMP TABLE STATISTIC 
	( DATE DATE, F0 INT, F1 INT, F2 INT, F3 INT, F_OUT INT);
	
	LOOP
		EXIT WHEN C_DATE > MAX_DATE;
		
		SELECT COUNT(*) INTO F0
		FROM STATUS_HISTORY
		WHERE STATUS = 0 AND DATE_TRUNC('DAY', VALID_FROM) <= C_DATE 
			  AND (DATE_TRUNC('DAY', VALID_TO) >= C_DATE OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F1
		FROM STATUS_HISTORY
		WHERE STATUS = 1 AND DATE_TRUNC('DAY', VALID_FROM) <= C_DATE 
			  AND (DATE_TRUNC('DAY', VALID_TO) >= C_DATE OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F2
		FROM STATUS_HISTORY
		WHERE STATUS = 2 AND DATE_TRUNC('DAY', VALID_FROM) <= C_DATE 
			  AND (DATE_TRUNC('DAY', VALID_TO) >= C_DATE OR VALID_TO IS NULL);
		
		SELECT COUNT(*) INTO F3
		FROM STATUS_HISTORY
		WHERE STATUS = 3 AND DATE_TRUNC('DAY', VALID_FROM) <= C_DATE 
			  AND (DATE_TRUNC('DAY', VALID_TO) >= C_DATE OR VALID_TO IS NULL);
			  
		SELECT COUNT(*) INTO F_OUT
		FROM STATUS_HISTORY
		WHERE STATUS = -1 AND VALID_FROM::DATE <= C_DATE::DATE;
		--DATE_TRUNC('DAY', VALID_FROM) <= C_DATE AND (DATE_TRUNC('DAY', VALID_TO) >= C_DATE OR VALID_TO IS NULL);
			
		INSERT INTO STATISTIC
		VALUES (C_DATE::DATE, F0, F1, F2, F3, F_OUT);
		
		C_DATE := C_DATE + INTERVAL '1 DAY';
	END LOOP;
	
	RETURN QUERY SELECT * FROM STATISTIC;
	DROP TABLE STATISTIC;
END;
$$
---++---